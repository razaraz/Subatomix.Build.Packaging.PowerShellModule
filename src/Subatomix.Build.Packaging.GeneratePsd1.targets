<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This project file is called in an external MSBuild instance to use proprty substitution -->

  <!-- We need to manually find the Directory.Build.[props, targets] files relative to the RootParentProject, rather than this file which is in the NuGet cache -->
  <PropertyGroup>
    <RootParentProjectDirectory>$([System.IO.Directory]::GetParent($(RootParentProject)))</RootParentProjectDirectory>
  </PropertyGroup>

  <PropertyGroup Condition="'$(DirectoryBuildPropsPath)' == ''">
    <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
    <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(RootParentProjectDirectory)', '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(DirectoryBuildTargetsPath)' == ''">
    <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
    <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(RootParentProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
  </PropertyGroup>

  <!-- We need to manually set the MSBuildProjectExtensionsPath so that it resolves relative to the RootParentProject -->
  <PropertyGroup Condition="'$(MSBuildProjectExtensionsPath)' == ''">
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>

    <MSBuildProjectExtensionsPath>$(RootParentProjectDirectory)\$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
  </PropertyGroup>

  <Import Project="$(RootParentProject)" />

  <!-- This is the file that is generated by the PowershellModule targets and has the generated properties used for substitution -->
  <Import Project="$(GeneratedPropertyImportFile)" />

  <UsingTask TaskName="ReplacePropertiesInFile" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Extension />
      <Properties ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true"/>
      <Result ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
<![CDATA[
        string regex = @"(?<=[^\$@])\{(?<Property>[A-Za-z0-9]+)\}";
        if (Files.Length > 0)
        {
          // Transform the properties into a dictionary
          var properties = Properties.ToDictionary(prop => prop.GetMetadata("Name"), prop => prop.GetMetadata("Value"));

          Log.LogMessage(MessageImportance.Low, "Properties to use for replacement:");

          foreach(var prop in properties)
          {
            Log.LogMessage(MessageImportance.Low, $"\t{prop.Key} = {prop.Value}");
          }

          Result = new TaskItem[Files.Length];
          foreach (ITaskItem file in Files)
          {
            uint i = 0;
            string filePath = file.GetMetadata("FullPath");
            string rootDir = file.GetMetadata("RootDir");
            string recursiveDir = file.GetMetadata("Directory");
            string fileName = file.GetMetadata("Filename");
            string newFilePath = rootDir + recursiveDir + fileName + Extension;

            Log.LogMessage(MessageImportance.Low, $"Replacing MSBuild Properties in file: {filePath}");

            using (StreamReader reader = File.OpenText(filePath))
            {
              string newFileContents = Regex.Replace(
                reader.ReadToEnd(),
                regex,
                (match) => {
                  string propertyName = match.Groups["Property"].Value;
                  string propertyValue = properties.ContainsKey(propertyName) ? properties[propertyName] : string.Empty;
                  Log.LogMessage(MessageImportance.Low, $"Replacing property: Name<{propertyName}> Value<{propertyValue}>");
                  return propertyValue;
                }
              );

              Log.LogMessage(MessageImportance.Low, $"Writing replaced MSBuild properties to: {newFilePath}");

              using (StreamWriter writer = new StreamWriter(newFilePath))
              {
                writer.Write(newFileContents);
              }

              Result[i++] = new TaskItem(newFilePath);
            }
          }
        }
]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="GeneratePsd1File"
          DependsOnTargets="GeneratePowerShellItemLists"
          Inputs="@(Psd1Template);@(Psd1Replacement)"
          Outputs="@(Psd1Template->'%(RootDir)%(Directory)%(Filename)')">
    
    <ReplacePropertiesInFile Files="@(Psd1Template)" Properties="@(Psd1Replacement)">
      <Output ItemName="GeneratedPsd1" TaskParameter="Result" />
    </ReplacePropertiesInFile>
  </Target>

</Project>
